\documentclass[paper=a4, fontsize=11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{fourier}

\usepackage[english]{babel}															% English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}	
\usepackage{url}
\usepackage{listings} % listings to include code samples
\usepackage{xcolor} % to change color in code listings

\usepackage{caption}
\usepackage{cleveref}

%%% Equation and float numbering
\numberwithin{equation}{section}		% Equationnumbering: section.eq#
\numberwithin{figure}{section}			% Figurenumbering: section.fig#
\numberwithin{table}{section}				% Tablenumbering: section.tab#


%hyphenation
\hyphenation{back-logs}
\newcommand*\idstyle{%
         \expandafter\id@style\the\lst@token\relax
 }
% set parameters for lstlisting and lstinline
\lstset{
  breaklines=true, % Enables wrapping in lstlisting environment.
  backgroundcolor=\color[HTML]{F8F8F8},
  frame=tlrb,
  basicstyle=\ttfamily, % the size of the fonts that are used for the code
  keepspaces=true, 
  framextopmargin=5pt,
  framexleftmargin=5pt,
  framexrightmargin=5pt,
  framexbottommargin=5pt,
  commentstyle=\itshape\color[HTML]{999988},
  rulecolor=\color[HTML]{DDDDDD},
  stringstyle=\color[HTML]{dd1144},
  keywordstyle=\color[HTML]{990000},
  identifierstyle=\color[HTML]{333333},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  keywords={print, read, if, else, elseif, do, end, while, const, def, begin, func},
  keywordstyle=\color[HTML]{333333}\bfseries, 
  % numbers=left, %we need line numbers to make line wrapping obvious
  numberstyle=\color[HTML]{888888}, %we want line numbers to blend in
  tabsize=4,
  literate={`}{${}^\backprime$}1
           {_}{$\_$}1
           {"}{\textquotedbl}1
           {'}{\textquotesingle}1
}
\renewcommand{\lstlistingname}{Code}



%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	% Horizontal rule

\title{
		%\vspace{-1in} 	
		\usefont{OT1}{bch}{b}{n}
		\normalfont \normalsize \textsc{University of Twente} \\ [25pt]
		\horrule{0.5pt} \\[0.4cm]
		\huge Alia Programming Language \\
		\horrule{2pt} \\[0.5cm]
}
\author{
		\normalfont 								\normalsize
        Fedor Beets\\[-3pt]						\small
        s1227874\\[-3pt]        				\small
        Campuslaan 27\\[8pt]					\normalsize
        Joost van Doorn\\[-3pt]					\small
        s1095005\\[-3pt]						\small
        Dalsteindreef 2404, Diemen\\[8pt]			\normalsize
        \today
}
\date{}


%%% Begin document
\begin{document}
\maketitle
\newpage
\section*{Introduction}
The Alia programming language was built for the final project of the compiler construction course at the University of Twente. In this final project a programming language is specified and implemented in antlr (ANother Tool for Language Recognition). A compiler is built to translate code into a type of machine instructions. The type of machine instructions can vary from language to language. Over the first half of compiler construction several small pieces of the process of building a compiler are individually learned and tested, brought to culmination in the final project where the entire track is gone through and a usable language is produced. 

This document serves as a specification of the Alia Programming Language (Alia for short) as well as an explanation of the inner workings of the Alia compiler. In it we will give a short description of the Alia Programming Language in the context of programming languages, explain some of the problems faced and solutions concoted during the construction of the Alia compiler,  give a specification of the Alia language with the help of the syntax, context-constraints and semantics. Also in this document are the transformations that show how the symbols of the language are turned into JVM instructions, a description of all the auxiliary java code made for the compiler, a set of tests is described to give confidence in the correctness of the compiler and lastly conclusions are drawn from the project.

\section{Alia Programming Language}
%De programmeertaal
%Maximaal een A4
The Alia programming language is an expression language with type inference. Alia code is compiled to Java bytecode and can be run using the Java Virtual Machine (JVM). As an expression language every statement has a return type. Functional statements such as print, read and conditional statements all return values. For example the print function may return a value which can be used in an assignment statement.

\begin{lstlisting}
x = print(34) + 1 // x is assigned 35
\end{lstlisting}

Alia contains compound statement which are a series of statements with the last statement as return value, compound statements are used in conditional statements and can be explicitly used for scoping.

\begin{lstlisting}
x = begin
    y = 3 // Only declared in this scope
    y + 1 // Return value for the compound statement
end
if y = true; y && x < 10 do // y here has a different scope
    print(y) // Print the value of y
    print('t')
end
\end{lstlisting}

Types in Alia are inferred and do not need explicit declarations. Types can be declared explicitly within an assignment statement, but are not required. In the current form of the programming language, type inference can always deduce the type of a declaration. However in an extended version of Alia with functions and procedures, explicit type declarations will be required in cases where type inference will not be able to deduce the type of the variable or function return type. Type inference makes programming easier, it reduces the work of the programmer by making explicit type declarations optional, and reduces the amount of code required for variable declarations. Type checking is maintained and the programmer still has the option to add type declarations if it helps clarify the code.

\begin{lstlisting}
x = 54 : int // x is assigned 54, and is explicitly declared as an int
\end{lstlisting}


%Typer inference
%Expression language

\section{Problems and solutions}
During the construction of the Alia compiler we ran into some problems, as is to be expected during any first time construction of a compiler. In this section we will explain some of the bigger problems that we faced as well as the solutions that we applied.

Scope definition: Because we do not have explicit declarations we cannot redefine a variable inside a new scope. There would be no way to distinguish between redefining a variable in a new scope and reassigning the value that was given to a variable to be used later. With a new variable that overwrites an old one for a temporary scope you would need to assign a new space in memory. We have decided that we want this in our programming language, this is because if you can redeclare a variable inside a new scope then you are only making it more confusing for yourself as a coder. On the other hand not being able to assign a new value to a variable in a new scope destroys a large part of the functionality of language. For these reasons we have chosen to leave it as is.

String template expressions: StringTemplate does not allow you to evaluate an expression inside of a string template. This was purposefully implemented to stop you from putting a large part of the logic in the string template itself. The problem that we have with this is that there are issues that are specific to the creation of java bytecode that must now be evaluated in the antlr part of the program, and must be passed in the creation of any possible target platform. The first time this became a problem was what instructions to use for outputting any given number. A naive solution to this would be to always use the instruction for loading a large number like an integer. But java has special instructions for loading the numbers -1 through 5 and loading smaller numbers that fit on a byte or a short, so we wanted to use these. To solve this issue we created a function that calculated what type a number can fit into in the CodeGeneratorAux class which passes a number of booleans wrapped in a NumberType to the string template. We then use conditional templates to emit different instructions depending on the number to be put on the stack.



%uitleg over de wijze waarop je de problemen die je bent tegengekomen bij het maken van de opdracht hebt opgelost (maximaal twee A4-tjes)

\section{Syntax, context-constraints and semantics}
The concrete syntax of Alia is defined as follows, the abstract syntax follows afterwards:

\begin{verbatim}
program = (func_def | (statement end_statement) | \n)*;

statements = (statement (end_statement statements)? | \n statements)?;
statements_cond = (statement (end_statement statements)? | \n statements_cond )?;

statement = (expr_assignment | const_assignment) (; type)?
			| while_stmnt 
			;

end_statement = \n | ";" | EOF;

expr_assignment = (exprPrint "=") expr_assignment
				| expr 
				;

const_assignment = CONST exprPrint "=" primitive;

expr = expr1 ((or | "||") expr1)*;
expr1 = expr2 ((and | "&&") expr2)*;
expr2 = expr3 ((">" | ">=" | "<" | "<=" | "==" | "!=" )^ expr3)*;
expr3 = expr4 (("+" | "-")^ expr4)*;
expr4 = expr5 (("*" | "/" | "%")^ expr5)*;
expr5 = "!" operand | operand | expr_minus | expr_plus;
expr_minus = "-" operand;
expr_plus = "+" operand;
operand = read |
	   	  print |
	   	  if_stmnt |
	   	  "(" expr ")" |
	   	  compound_stmnt |
	   	  primitive |
	   	  func_exprPrint
		;
		  
compound_stmnt = begin statements end;

primitive = number | character | boolean;

func_exprPrint = exprPrint ( "(" exprlist? ")" )?;

while_stmnt = WHILE statements_cond DO statements END;

if_stmnt = IF statements_cond DO statements else_stmnt? END;

else_stmnt = ELSEIF statements_cond DO statements else_stmnt?
			| (ELSE statements)
			;

print = PRINT "(" exprlist ") ;
read = READ "(" varlist ") ;

varlist = exprPrint ("," exprPrint)*;
exprlist = expr ("," expr)*;

func_def = DEF exprPrint "(" varlist ")";
\end{verbatim}


\subsection{Semantics and context constraints:}
The semantics and context constraints are defined using the abstract syntax of the Alia language.

program = statement+;
The program 'C' is run by executing the command C.
The program construct opens a new scope before any of the statements. This scope is closed after the last statement.
\begin{verbatim}
statements = statement*;
\end{verbatim}
\begin{verbatim}
statement = 	WHILE statements DO statements
			|	expr
			;
\end{verbatim}
The while statement 'while S1 do S2' is executed as follows. The statement S1 is evaluated, if its value is true then S2 is evaluated and the while statement is run again. If the value of S1 is false then the execution is completed. S1 must be of type boolean. This statement is of type void.
The expression 'E' is executed as follows. E is evaluated. This statement is of type E.

\begin{verbatim}
expr = operand
	|	OR expr expr
    |   OR_ALT expr expr
    |   AND expr expr
    |   AND_ALT expr expr
    |   EQ expr expr
   	|   NQ expr expr
   	|   LE expr expr
   	|   GE expr expr
   	|   GT expr expr
   	|   LT expr expr
	
	|   PLUS expr expr
    |   MINUS expr expr
    |   TIMES expr expr
    |   DIV expr expr
    |   MOD expr expr
	
	| 	PRINT exprlist
	| 	READ varlist
	
	| 	NOT operand)
	|	(PLUS_OP | MINUS_OP) operand
	|   IF
   			statements
   			DO statements
   			else_stmnt?
   	|   BECOMES IDENTIFIER expr type?
	|   COMPOUND statements
	|   CONST IDENTIFIER BECOMES primitive (COLON type)?
	\end{verbatim}
The expression 'O' is is executed as follows. O is evaluated. The type is the type of O. \\
The expression 'or E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. An or is called on E1 and E2. True iff E1 or E2. E1 and E2 must be of type Boolean. The type is Boolean.\\
The expression '|| E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. An or is called on E1 and E2. True iff E1 or E2. E1 and E2 must be of type Boolean. The type is Boolean.\\
The expression 'and E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. An and is called on E1 and E2. True iff E1 and E2. E1 and E2 must be of type Boolean. The type is Boolean.\\
The expression '\&\& E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. An and is called on E1 and E2. True iff E1 and E2. E1 and E2 must be of type Boolean. The type is Boolean.\\

The expression '== E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. An equals is called on E1 and E2. True iff E1 equal to E2. E1 and E2 must be of the same type. The type is Boolean.\\
The expression '!= E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A not equals is called on E1 and E2. True iff E1 is not equal to E2. E1 and E2 must be of the same type. The type is Boolean.\\
The expression '<= E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A less than or equal to is called on E1 and E2. True iff E1 is less than or equal to E2. E1 and E2 must be of the same type. The type is Boolean.\\
The expression '>= E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A greater than or equal to is called on E1 and E2. True iff E1 is greater than or equal to E2. E1 and E2 must be of the same type. The type is Boolean.\\
The expression '> E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A greater than is called on E1 and E2. True iff E1 is greater than E2. E1 and E2 must be of the same type. The type is Boolean.\\
The expression '< E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A less than is called on E1 and E2. True iff E1 is less than E2. E1 and E2 must be of the same type. The type is Boolean.\\

The expression '+ E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. An addition is called on E1 and E2. E1 and E2 must be of type Int.\\
The expression '- E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A subtraction is called on E1 and E2. E1 and E2 must be of type Int.\\
The expression '* E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A multiplication is called on E1 and E2. E1 and E2 must be of type Int.\\
The expression '/ E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A division is called on E1 and E2. E1 and E2 must be of type Int.\\
The expression '% E1 E2' is executed as follows. E1 is evaluated. E2 is evaluated. A remainder is called on E1 and E2. E1 and E2 must be of type Int.\\
The type of +,-,*,/,%  is Int.

The expression 'print EL' is executed as follows. The expression list EL is evaluated. All evaluated expressions are then written to the output. The type of the expression is the type of EL.
The expression 'read VL' is executed as follows. The variable list evaluated. For every variable a line is read from the input, the first character of this line is assigned as value to the variable. The type of the expression is the type of VL.

The expression '!O'  is executed as follows. O is inverted. O must be of type boolean. The type of the expression is the type of O.
The '+O' and '-O' are executed as follows. For '+O' nothing is done. For '-O' the operand is negated. O must be of type Int. The expression is the type of O.

The expression 'if S1 do S2 else\_stmnt?' is executed as follows. S1 is evaluated. If S1 is true, then S2 is evaluated. If S1 is false, then if there is an else\_stmnt it is evaluated, otherwise the execution is complete. S1 must be of type Boolean. If there is an else statement, and the statements in the else statement are of the same type as S2, then this expression is of the type of S2. Else this expression is of type void.
The expression '= I E T?' is executed as follows. I is bound to the value yielded by the expression E. If T was included, T and E must be of the same type. The expression is of type E.
The expression 'COMPOUND S1' is executed as follows. S1 is executed. This expression is of type S1.
The expression 'const I = P (; T)?' is executed as follows. I is bound to the value P. If T was included, T and E must be of the same type. The expression is of type P.

\begin{verbatim}
else_stmnt = ELSEIF statements
			DO statements
			else_stmnt?
		|	ELSE statements
	   	;
\end{verbatim}
The statement 'elseif S1 do S2 elsestmnt?' is executed as follows. S1 is evaluated. If S1 is true, S2 is executed. If S1 is false, and elsestmnt has been provided then elsestmnt is executed. The execution is then complete. S1 must be of type boolean. If there is an else statement, and the statements in the else statement are of the same type as S2, then this expression is of the type of S2. Else this expression is of type void.
The statement 'else S1' is executed as follows. S1 is executed. The type of the statement is the type of S1.

\begin{verbatim}
operand = 	IDENTIFIER
		|	NUMBER
		| 	CHAR_EXPR
		|	BOOLEAN
		;
\end{verbatim}
The operand 'I' identifies a the value or variable bound to I. The operand I must have been previously declared. The type of the operand is the type of that value or variable.
The operand 'N' evaluates to a number. N can be no larger than 2147483647 and no smaller than -2147483648. N is of type Int.
The operand 'C' evaluates to a character. C is of type Char.
The operand 'B' evaluates to a boolean, either true or false. C is of type Bool.

\begin{verbatim}
varlist = identifier (identifier)*;
\end{verbatim}
The list 'I I*' evalutes to a list of identifiers. If there is one identifier the type of the list is the type of that identifier. If there are 2 or more, the type is void.
\begin{verbatim}
exprlist = expr (expr)*;
\end{verbatim}
The list 'E E* evaluates to a list of expressions. None of the expressions may be void. If there is one expression, the list of the type of E. If there are 2 or more, the type is void.
\begin{verbatim}	
primitive =	NUMBER
		|	CHAR_EXPR
		|	boolean_expr
		;
\end{verbatim}
The operand 'N' evaluates to a number. N can be no larger than 2147483647 and no smaller than -2147483648. N is of type Int.
The operand 'C' evaluates to a character. C is of type Char.
The operand 'B' evaluates to a boolean, either true or false. C is of type Bool.

\section{Translation rules} %Vertaalregels, hoofdstuk 7 van Watt & Brown
The translation rules for Alia to Java bytecode are shown here. Some details have been abstracted away in favor of readability, these details include specific label names, translation rules which are dependent on the type of the expression (such as print and read), and some specific rules where pop statements are included.

\begin{verbatim}
execute [I = E]
    expr [E]
    istore a // address of variable I
    exprPrint [I]

expr [while C do S end] =
    goto COND
    WHILE:
    execute [S]
    COND:
    execute [C]
    ifne WHILE

expr [if C do S E end] =
    execute [C]
    ifeq ELSE
    execute [S]
    goto NEXT
    ELSE:
    exprElse [E]
    NEXT:
    
exprElse [elseif C do S E]
    execute [C]
    ifeq ELSE
    execute [S]
    goto NEXT
    ELSE:
    exprElse [E]
    NEXT:
    
    
exprElse [else S] =
    execute [S]

expr [E1 O E2] =
    expr [E1]
    expr [E2]
    instruction [O] // The specific instruction, e.g. iadd etc.
    
expr [E1 OC E2] =
    expr [E1]
    expr [E2]
    if_icmp $+7 // Go to iconst_1 if it is true, this line contains the specific instruction
    iconst_0
    goto $+4 // Go to the line after iconst_1
    iconst_1
    
expr [-E]
    expr [E]
    ineg
 
expr [+E]
    expr [E]

expr [not E]
    expr[E]
    ifeq $+7
    iconst_0
    goto $+4
    iconst_1

expr [begin S end]
    execute [S]

print [S] =
    getstatic java/lang/System/out Ljava/io/PrintStream;
    execute [S]
    invokevirtual java/io/PrintStream/println(T)V

expr [print(S)] =
    getstatic java/lang/System/out Ljava/io/PrintStream;
    execute [S]
    istore_1
    iload_1
    invokevirtual java/io/PrintStream/println(T)V
    iload_1
    
expr [print(S, L)] =
    print [S]
    executePrint [L]

executePrint [S, L]
    print [S]
    executePrint [L]
    
executePrint [S]
    print [S]
    
read [] =
    invokestatic java/lang/System/console()Ljava/io/Console;
    invokevirtual java/io/Console/readLine()Ljava/lang/String;
    invokestatic java/lang/Type/parseType(Ljava/lang/String;)T

execute [read(I)] =
    read []
    istore_1
    iload_1
    istore a ; address of variable I
    execute [S]
    iload_1
execute [read(I, L)] =
    read []
    istore a ; address of variable I
    exprRead [L]
    
exprRead [I, L]
    read []
    istore a ; address of variable I
    exprRead [L]
    
exprRead [I]
    read []
    istore a ; address of variable I

execute [S \n S] =
    execute [S]
    execute [S]
    
execute [S ; S] =
    execute [S]
    execute [S]


execute [S] =
    expr [S]
    
exprPrint [I] =
    iload a ; address of variable I

operand [N] =
    number [N] // iconst n

program [S] =
    .class public filename.j ; target file
    .super java/lang/Object
    
    .method public \<init\>()V
       aload_0
       invokenonvirtual java/lang/Object/\<init\>()V
       return
    .end method
    
    .method public static main([Ljava/lang/String;)V
       .limit stack stackMax ; stackMax = maximum size of the stack
       .limit locals localSize ; localSize = amount of local variables required
       
       execute [S]
    
       return
    .end method
\end{verbatim}

\section{Java-code}
The checker uses an auxiliary class CheckerAux that handles a large portion of the logic of the checking, such as if two types are the same. This class also declares variables and constants into the symbol table. CheckerAux also has methods to access the symbolTable so that it throws AliaExceptions instead of more general exceptions. The symbol table has a HashMap of Names, IdEntries and a scopestack that has all exprPrints declared on a scope. Like every symbolTable it keeps track of what exprPrints have been declared on what levels. The IdEntries also store information about whether the exprPrint is a constant and what type it is.

Most of the logic for type checking is implemented in CheckerAux, to do the type checking a set of type classes are used, such as \_Int and \_Bool. All of these classes inherit from \_Type and have a string with their typename. We chose to make all types into distinct classes instead of an enum because this will allow for extension of say the \_Int class with a \_Float class or of the \_Char class with a \_String class. In this way we can more easily add addtional types to Alia and a future \_Long and \_Float could be compared using inheritence.

The code generation makes use of CodeGeneratorAux. This seperates some of the logic from the antlr files. In particular CodeGeneratorAux calculates what kind of java type can be used for any given number, this choice is explained in the problems section. To do this it uses the NumberType class, which acts as a container for a number of booleans so that they can be passed more elegantly. The other part that CodeGeneratorAux takes care of is the logic for the stack management, incrementing and decrementing the amount that is still to be pushed off the stack in the code generation.

For error handling AliaException and AliaTypeException are used. These exceptions are thrown in the checker when ever a type is violated. If there is a syntactical mistake then the classes generated by antlr will throw exceptions. For run time errors standard java exceptions are also used.

After the checking fase has been completed a decorated AST is returned. The decorated AST stores the type information that was found in the corresponding nodes, such as for all binary expressions. We also store the identifying numbers for all applied usages of exprPrints (except for constants which are replaced), these ascending numbers are gotten from the IdEntries using CheckerAux and are stored with the nodes, for later use in the code generation.
\section{Tests}

\section{Conclusion}
\section{Appendices}
%ANTLR LEXER
%ANTLR PARSER
%ANTLR TREEPARSER
%Een testprogramma (invoer/uitvoer)
% 
%%% End document
\end{document}
