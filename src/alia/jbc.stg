group tmg;

file(instructions) ::= <<
; Jasmin JBC assembler code generated by AliaCodeGenerator
.class public NoJad.j
.super java/lang/Object

.method public \<init\>()V
   aload_0
   invokenonvirtual java/lang/Object/\<init\>()V
   return
.end method

.method public static main([Ljava/lang/String;)V
   .limit stack 20
   .limit locals 20
   
   <instructions; separator="\n">

   return
.end method
>>

statements(instructions) ::= <<
<instructions; separator="\n">
>>

statement(instruction) ::= <<
<instruction>
>>
whilestmt() ::= <<
; WHILE
>>
printstmt(statements) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<statements>
invokevirtual java/io/PrintStream/println(I)V ; add right constant pool reference bytes for println
>>
readstmt() ::= <<
; READ
>>
identifier(addr) ::= <<
iload_<addr>
>>
number(n, numberType) ::= <<
$if(numberType.lessthanfive)$
iconst_<n>
$elseif(numberType.minusone)$
iconst_m1
$elseif(numberType.byteType)$
bipush <n>
$elseif(numberType.shortType)$
sipush <n>
$elseif(numberType.intType)$
ldc <n>
>>
character(c) ::= <<

bpush <c> ; Char
>>
boolean(b) ::= <<
iconst_<if(b)>1<else>0<endif> ; Bool
>>

declare(var, addr) ::= <<
PUSH        1
>>

assign(var, addr, expr) ::= <<
<expr>
istore_<addr>                  ; store value into <var>
>>


binexpr(x, y, instr) ::= <<
<x> ; expr1
<y> ; expr2
i<instr>
>>

binexprcomp(x, y, instr) ::= <<
<x>
<y>
if_icmp<instr> ;; line_number_store
iconst_1
goto ;; line_number_store
iconst_0
>>

loadvar(var, addr) ::= <<
LOAD(1)     <addr>[SB]                  ; load value of <var>
>>

loadnum(val) ::= <<
LOADL       <val>
>>

unarynot(x, instr) ::=  <<
<x>   ; if x is 0 make it 1, if x is 1 make it 0
ifeq ; jump forward if 0        jump current+7
iconst_0  ; if original was 1, load 0
goto ; add addr    ;jump to current +4
iconst_1 ; if original was 0, load 1
>>

unaryplus(x, instr) ::= <<  ; does nothing, is feature
<x>
>>

unarymin(x, instr) ::=  <<
<x>
i<instr>
>>

if(statements1, statements2) ::= <<
  <statements1>
  if_icmpne ; add address   ; jump over statements
  <statements2>
>>

elseif(statements1, statements2) ::= <<
  <statements1>
  if_icmpne ; add address   ;jump over statements
  <statements2>
>>

elsemaybe(statements)           ::= <<
<statements>
; iets met returnen van lengte
>>
