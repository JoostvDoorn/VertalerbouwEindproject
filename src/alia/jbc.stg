group tmg;

file(instructions) ::= <<
// JBC assembler code generated by AliaCodeGenerator
<instructions; separator="\n">
return                                    // end of program
>>

statements(instructions) ::= <<
<instructions; separator="\n">
>>

statement(instruction) ::= <<
<instruction>
>>
whilestmt() ::= <<
// WHILE
>>
printstmt() ::= <<
// PRINT
>>
readstmt() ::= <<
// READ
>>
identifier(addr) ::= <<
iload_<addr>
>>
number(n) ::= <<
iload_<n>
>>
character(c) ::= <<
iload_<c> // Char
>>
boolean(b) ::= <<
iload_<b> // Bool
>>

declare(var, addr) ::= <<
PUSH        1
>>

assign(var, addr, expr) ::= <<
<expr>
istore_<addr>                  // store value into <var>
>>

print(statements) ::= <<
getstatic //add right constant pool reference bytes for printstream
<statements>
invokevirtual //add right constant pool reference bytes for println
>>

binexpr(x, y, instr) ::= <<
<x> // expr1
<y> // expr2
i<instr>
>>

binexprcomp(x, y, instr) ::= <<
<x>
<y>
if_icmp<instr> //; line_number_store
iconst_1
goto //; line_number_store
iconst_0
>>

loadvar(var, addr) ::= <<
LOAD(1)     <addr>[SB]                  // load value of <var>
>>

loadnum(val) ::= <<
LOADL       <val>
>>

unarynot(x, instr) ::=  <<
<x>   //if x is 0 make it 1, if x is 1 make it 0
ifeq //jump forward if 0        jump current+7
iconst_0  //if original was 1, load 0
goto // add addr    //jump to current +4
iconst_1 //if original was 0, load 1
>>

unaryplus(x, instr) ::= <<  //does nothing, is feature
<x>
>>

unarymin(x, instr) ::=  <<
<x>
i<instr>
>>

if(statements1, statements2) ::= <<
  <statements1>
  if_icmpne //add address   //jump over statements
  <statements2>
>>

elseif(statements1, statements2) ::= <<
  <statements1>
  if_icmpne //add address   //jump over statements
  <statements2>
>>

elsemaybe(statements)           ::= <<
<statements>
//iets met returnen van lengte
>>
