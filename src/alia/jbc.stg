group tmg;

file(instructions,stackMax,localSize,filename) ::= <<
; Jasmin JBC assembler code generated by AliaCodeGenerator
.class public <filename>.j
.super java/lang/Object

.method public \<init\>()V
   aload_0
   invokenonvirtual java/lang/Object/\<init\>()V
   return
.end method

.method public static main([Ljava/lang/String;)V
   .limit stack <stackMax>
   .limit locals <localSize>
   
   <instructions; separator="\n">

   return
.end method
>>

statements(instructions) ::= <<
<instructions; separator="\n">
>>

exprPopInterleaved(instruction, pop) ::= <<
<pop>
<instruction>
>>

exprPop(instruction, pop) ::= <<
<instruction>
<pop>
>>

statement(instruction) ::= <<
<instruction>
>>

whilestmt(statement, expr, labelCond, labelWhile) ::= <<
goto COND<labelCond>		; Jump to while condition
WHILE<labelWhile>:
<statement>
COND<labelCond>:
<expr>		; Execute condition
ifne WHILE<labelWhile>		; Jump to start of inner while statement
>>

printstmt(firststatement, statements, type, t) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<firststatement; separator="\n">
<if(type._void)>
<else>
istore_1 ; TODO: bepaal welke lokale variabele we gebruiken voor dit doeleinde
iload_1 ; Deze lokale variabele is niet goed, want die kan hergebruikt worden door een andere print...
<endif>

invokevirtual java/io/PrintStream/println(<t>)V ; add right constant pool reference bytes for println

<statements; separator="\n">

<if(type._void)>
<else>
iload_1 ; repush the value to the stack if it is used again
<endif>

>>

printexpr(statements, t) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<statements; separator="\n">
invokevirtual java/io/PrintStream/println(<t>)V ; add right constant pool reference bytes for println
>>

readstmt(statements, addr, void, type) ::= <<
invokestatic java/lang/System/console()Ljava/io/Console;
invokevirtual java/io/Console/readLine()Ljava/lang/String;

<if(type._int)>
invokestatic java/lang/Integer/parseInt(Ljava/lang/String;)I
<elseif(type._bool)>
invokestatic java/lang/Boolean/parseBoolean(Ljava/lang/String;)Z
<elseif(type._char)>
iconst_0
invokevirtual java/lang/String/charAt(I)C
<endif>


<if(type._void)>
<else>
istore_1
iload_1
<endif>

istore <addr>                  ; store value
<statements>
<if(void)>
<else>
iload_1 ; repush the value to the stack if it is used again
<endif>
>>

readvar(var, addr, expr) ::= <<
invokestatic java/lang/System/console()Ljava/io/Console;
invokevirtual java/io/Console/readLine()Ljava/lang/String;

<if(type._int)>
invokestatic java/lang/Integer/parseInt(Ljava/lang/String;)I
<elseif(type._bool)>
invokestatic java/lang/Boolean/parseBoolean(Ljava/lang/String;)Z
<elseif(type._char)>
iconst_0
invokevirtual java/lang/String/charAt(I)C
<endif>


istore <addr>                  ; store value into <var>

>>

identifier(addr) ::= <<
iload <addr>
>>

number(n, numberType) ::= <<
<if(numberType.lessthanfive)>
iconst_<n>
<elseif(numberType.minusone)>
iconst_m1
<elseif(numberType.byteType)>
bipush <n>
<elseif(numberType.shortType)>
sipush <n>
<else>
ldc <n>
<endif>
>>

character(c) ::= <<
bipush <c> ; Char
>>

boolean(b) ::= <<
iconst_<if(b)>1<else>0<endif> ; Bool
>>


assign(var, addr, expr) ::= <<
<expr>
istore <addr>                  ; store value into <var>
iload <addr>				   ; put value on the stack TODO: decide if this is good enough
>>

binexpr(x, y, instr) ::= <<
<x> ; expr1
<y> ; expr2
i<instr>
>>

binexprcomp(x, y, instr) ::= <<
<x>
<y>
if_icmp<instr> $+7 ; Go to iconst_1 if it is true
iconst_0
goto $+4 ; Go to the line after iconst_1
iconst_1
>>


unarynot(x, instr) ::=  <<
<x>   ; if x is 0 make it 1, if x is 1 make it 0
ifeq $+7 ; Go to iconst_1 if it is false
iconst_0
goto $+4 ; Go to the line after iconst_1
iconst_1 ; if original was 0, load 1
>>

unaryplus(x, instr) ::= <<  ; does nothing, is feature
<x>
>>

unarymin(x, instr) ::=  <<
<x>
i<instr>
>>

ifstmnt(cond, statements, elseStmnts, labelElse, labelNext) ::= <<
  <cond>
  ifeq ELSE<labelElse>
  <statements>
  goto NEXT<labelNext>
  ELSE<labelElse>:
  <elseStmnts; separator="\n">
  NEXT<labelNext>:
>>

elseifstmnt(cond, statements, elseStmnts, labelElse, labelNext) ::= <<
  <cond>
  ifeq ELSE<labelElse>
  <statements>
  goto NEXT<labelNext>
  ELSE<labelElse>:
  <elseStmnts; separator="\n">
  NEXT<labelNext>:
>>

elsemaybestmnt(statements)           ::= <<
<statements>
>>
